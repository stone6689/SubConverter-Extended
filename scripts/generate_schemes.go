package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

const headerTemplate = `// Auto-generated by scripts/generate_schemes.go
// DO NOT EDIT MANUALLY
// Based on mihomo version: {{.Version}}

#pragma once
#include <vector>
#include <string>

namespace mihomo {
    const std::vector<std::string> SUPPORTED_SCHEMES = {
{{- range .Schemes}}
        "{{.}}",
{{- end}}
    };
}
`

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run generate_schemes.go <output_path>")
		os.Exit(1)
	}
	outputPath := os.Args[1]

	// 1. Get mihomo source path
	cmd := exec.Command("go", "list", "-m", "-f", "{{.Dir}}", "github.com/metacubex/mihomo")
	cmd.Dir = "../bridge"
	output, err := cmd.Output()
	if err != nil {
		fmt.Printf("Error finding mihomo source: %v\n", err)
		os.Exit(1)
	}
	mihomoPath := strings.TrimSpace(string(output))
	targetFile := filepath.Join(mihomoPath, "common/convert/converter.go")

	fmt.Printf("Analyzing %s...\n", targetFile)

	// 2. Parse AST
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, targetFile, nil, parser.ParseComments)
	if err != nil {
		fmt.Printf("Error parsing file: %v\n", err)
		os.Exit(1)
	}

	schemes := make([]string, 0)
	seen := make(map[string]bool)

	// 3. Walk AST
	ast.Inspect(node, func(n ast.Node) bool {
		fn, ok := n.(*ast.FuncDecl)
		if !ok || fn.Name.Name != "ConvertsV2Ray" {
			return true
		}

		fmt.Println("Found ConvertsV2Ray function")

		ast.Inspect(fn.Body, func(n ast.Node) bool {
			switchStmt, ok := n.(*ast.SwitchStmt)
			if !ok {
				return true
			}

			// Optional: check Tag
			if ident, ok := switchStmt.Tag.(*ast.Ident); ok {
				if ident.Name != "scheme" {
					return true
				}
			}

			fmt.Printf("Found switch statement with %d cases\n", len(switchStmt.Body.List))

			for i, caseClause := range switchStmt.Body.List {
				cc, ok := caseClause.(*ast.CaseClause)
				if !ok {
					continue
				}

				fmt.Printf("  Case %d: %d expressions\n", i, len(cc.List))

				for _, expr := range cc.List {
					switch v := expr.(type) {
					case *ast.BasicLit:
						if v.Kind == token.STRING {
							val := strings.Trim(v.Value, "\"")
							fmt.Printf("    -> Found String: %s\n", val)

							if val != "http" && val != "https" {
								if !seen[val] {
									schemes = append(schemes, val)
									seen[val] = true
								}
							}
						} else {
							fmt.Printf("    -> Found Literal (not string): %v\n", v.Kind)
						}
					default:
						fmt.Printf("    -> Found Non-Literal: %T\n", v)
					}
				}
			}
			return true
		})

		return false
	})

	if len(schemes) == 0 {
		fmt.Println("Warning: No schemes found!")
	} else {
		fmt.Printf("Total schemes found: %d\n", len(schemes))
	}

	// 4. Generate Output
	data := struct {
		Version string
		Schemes []string
	}{
		Version: "latest",
		Schemes: schemes,
	}

	f, err := os.Create(outputPath)
	if err != nil {
		fmt.Printf("Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	tmpl := template.Must(template.New("header").Parse(headerTemplate))
	tmpl.Execute(f, data)
	fmt.Printf("Successfully generated %s\n", outputPath)
}
